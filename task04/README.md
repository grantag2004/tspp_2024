Перед нами стояла задача реализации матричного умножения квадратных матриц размера N*N стандартным методом и с помощью векторизации SIMD для ARM архитектуры. 

Для решения задачи приведены две функции serial_multiply и vectorize_multiply, отвечающие за соответствующие способы. Функции для векторной реализации взяты из документации ARM NEON. Мною был рассмотрен Row-major способ представления матриц.

Размер матриц для тестов - 512, 1024, 2048.

Инициализация входных матриц происходит случайными числами от 0 до 1.

Результаты работы программы представлены на изображении.

![Results](https://github.com/grantag2004/tspp_2024/blob/task04/task04/Результаты.png)

Можно прийти к выводу, что при использовании размера регистра SIMD = 128 байт(4 числа float) ускорение примерно равно 2 пункта, что является существенной оптимизацией решения задачи! При сравнении результирующих матриц поэлементно мы получаем неожиданные результаты, ведь числа с плавающей точкой, которые, как правило, подвержены проблемам округления. При допустимой погрешности в 1e-9 количество несоответсвий равно 0. Может быть несколько причин. 

1. Если числа близки к единице или очень маленькие (например, меньше 1.0, как указано в инициализации), отклонения могут оказаться минимальными.

2. Архитектурные особенности: На некоторых архитектурах (например, ARM с NEON) арифметические операции могут иметь почти одинаковую точность для последовательных и векторизованных операций, особенно при небольшом количестве операций с плавающей запятой, что сводит к минимуму накопление ошибок.

